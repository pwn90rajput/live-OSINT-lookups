<script>
  // ===== Helper =====
  const el = id => document.getElementById(id);

  // Fetch JSON with transparent CORS fallback (AllOrigins)
  async function fetchJSON(url, opts = {}, timeoutMs = 12000) {
    // Try direct first
    const direct = await tryFetchJSON(url, opts, timeoutMs);
    if (!direct._error) return direct;

    // Fallback via AllOrigins proxy
    const proxiedURL = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
    const proxied = await tryFetchAsText(proxiedURL, opts, timeoutMs);
    if (!proxied._error) {
      try { return JSON.parse(proxied.text); }
      catch (e) { return { _error: `Proxy JSON parse failed: ${e.message}`, _url: url }; }
    }
    // If both fail, return the direct error (more informative)
    return direct;
  }

  async function tryFetchJSON(url, opts = {}, timeoutMs = 12000) {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    try {
      const res = await fetch(url, { ...opts, signal: controller.signal });
      clearTimeout(timer);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      clearTimeout(timer);
      return { _error: e.message || String(e), _url: url };
    }
  }

  async function tryFetchAsText(url, opts = {}, timeoutMs = 12000) {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    try {
      const res = await fetch(url, { ...opts, signal: controller.signal });
      clearTimeout(timer);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return { text: await res.text() };
    } catch (e) {
      clearTimeout(timer);
      return { _error: e.message || String(e), _url: url };
    }
  }

  // ===== Your existing functions (unchanged) you already had =====
  function parseInputToDomain(input) {
    try { if (/^https?:\/\//i.test(input)) return new URL(input).hostname; return input.split('/')[0].trim(); }
    catch { return input.trim(); }
  }
  function riskBadge(score){
    if (score >= 70) return `<span class="score high">${score} (High)</span>`;
    if (score >= 40) return `<span class="score med">${score} (Medium)</span>`;
    return `<span class="score low">${score} (Low)</span>`;
  }
  function isPunycodeOrWeird(domain) {
    const puny = domain.startsWith('xn--');
    const manyHyphens = (domain.match(/-/g) || []).length >= 3;
    const looksLikeIP = /^\d{1,3}(\.\d{1,3}){3}$/.test(domain);
    const longLabel = domain.split('.').some(l => l.length > 24);
    return { puny, manyHyphens, looksLikeIP, longLabel };
  }

  // ===== DNS / RDAP / IP helpers (unchanged from your version) =====
  async function lookupDNS(domain) {
    const aRes = await fetchJSON(`https://dns.google/resolve?name=${encodeURIComponent(domain)}&type=A`);
    const aaaaRes = await fetchJSON(`https://dns.google/resolve?name=${encodeURIComponent(domain)}&type=AAAA`);
    const mxRes = await fetchJSON(`https://dns.google/resolve?name=${encodeURIComponent(domain)}&type=MX`);
    const nsRes = await fetchJSON(`https://dns.google/resolve?name=${encodeURIComponent(domain)}&type=NS`);
    const txtRes = await fetchJSON(`https://dns.google/resolve?name=${encodeURIComponent(domain)}&type=TXT`);

    const flatten = r => (r && r.Answer ? r.Answer.map(a => a.data) : []);
    const lines = [];
    lines.push(`A: ${flatten(aRes).join(', ') || '—'}`);
    lines.push(`AAAA: ${flatten(aaaaRes).join(', ') || '—'}`);
    lines.push(`MX: ${flatten(mxRes).join(' | ') || '—'}`);
    lines.push(`NS: ${flatten(nsRes).join(' | ') || '—'}`);
    lines.push(`TXT: ${(flatten(txtRes).map(t=>t.replace(/^"|"$/g,'')).join(' | ')) || '—'}`);
    return { text: lines.join('\n'), ips: flatten(aRes) };
  }

  async function lookupRDAP(domain) {
    const rdap = await fetchJSON(`https://rdap.org/domain/${encodeURIComponent(domain)}`);
    if (rdap._error) return { text: `RDAP error: ${rdap._error}`, created: null };
    const created = rdap.events?.find(e => e.eventAction === 'registration')?.eventDate || null;
    const expires = rdap.events?.find(e => e.eventAction === 'expiration')?.eventDate || null;
    const registrar = rdap.entities?.find(e => e.roles?.includes('registrar'))?.vcardArray?.[1]?.find(v=>v[0]==='fn')?.[3] || null;
    const str = [
      `Domain: ${rdap.ldhName || domain}`,
      `Registrar: ${registrar || '—'}`,
      `Registered: ${created || '—'}`,
      `Expires: ${expires || '—'}`
    ].join('\n');
    return { text: str, created };
  }

  async function ipEnrich(ip) {
    const data = await fetchJSON(`https://ipapi.co/${encodeURIComponent(ip)}/json/`);
    if (data._error) return { ip, text:`${ip} – lookup error: ${data._error}` };
    const bits = [
      `IP: ${ip}`,
      `ASN: ${data.asn || '—'}`,
      `Org/ISP: ${data.org || data.asn_org || '—'}`,
      `Country: ${data.country_name || '—'}`,
      `Region/City: ${data.region || '—'} / ${data.city || '—'}`,
      `Latitude/Longitude: ${data.latitude ?? '—'} / ${data.longitude ?? '—'}`
    ];
    return { ip, text: bits.join('\n'), org: data.org || data.asn_org };
  }

  // ===== FIXED: Subdomains via urlscan with CORS fallback =====
  async function lookupSubdomains(domain) {
    const res = await fetchJSON(`https://urlscan.io/api/v1/search/?q=domain:${encodeURIComponent(domain)}`);
    if (res._error) return `urlscan search error: ${res._error}`;
    const set = new Set();
    (res.results || []).slice(0, 80).forEach(r => {
      const d = r?.page?.domain || r?.task?.domain;
      if (d && (d === domain || d.endsWith(`.${domain}`))) set.add(d);
    });
    return [...set].slice(0, 50).join('\n') || '—';
  }

  // ===== FIXED: Wayback CDX via CORS fallback =====
  async function wayback(domain) {
    const r = await fetchJSON(`https://web.archive.org/cdx/search/cdx?url=${encodeURIComponent(domain)}/*&output=json&fl=timestamp,original&limit=5&filter=statuscode:200&collapse=timestamp:8`);
    if (r._error) return `Wayback error: ${r._error}`;
    if (!Array.isArray(r) || r.length < 2) return 'No snapshots found.';
    const rows = r.slice(1).map(row => {
      const ts = row[0];
      const y = ts.slice(0,4), m = ts.slice(4,6), d = ts.slice(6,8);
      return `${y}-${m}-${d}  ${row[1]}`;
    });
    return `Recent snapshots:\n${rows.join('\n')}`;
  }

  // ===== Mail TXT / Robots same as before =====
  async function lookupMail(domain) {
    const txtRes = await fetchJSON(`https://dns.google/resolve?name=${encodeURIComponent(domain)}&type=TXT`);
    const txts = (txtRes.Answer || []).map(a => a.data.replace(/^"|"$/g,''));
    const spf = txts.find(t => /^v=spf1/i.test(t)) || '—';
    const dmarcRes = await fetchJSON(`https://dns.google/resolve?name=_dmarc.${encodeURIComponent(domain)}&type=TXT`);
    const dmarc = (dmarcRes.Answer || []).map(a=>a.data.replace(/^"|"$/g,'')).find(t=>/^v=DMARC1/i.test(t)) || '—';
    return `SPF: ${spf}\nDMARC: ${dmarc}`;
  }

  async function robotsAndSitemap(domain) {
    async function getText(url) {
      const r = await tryFetchAsText(url);
      return r._error ? `Not Found or blocked (${r._error})` : r.text.slice(0,800);
    }
    const robots = await getText(`https://${domain}/robots.txt`);
    const sitemap = await getText(`https://${domain}/sitemap.xml`);
    return `robots.txt:\n${robots || '—'}\n\nsitemap.xml:\n${sitemap || '—'}`;
  }

  // ===== Reputation (unchanged logic, uses ipEnrich etc.) =====
  async function reputation(domain, ips, createdISO) {
    const us = await fetchJSON(`https://urlscan.io/api/v1/search/?q=domain:${encodeURIComponent(domain)}`);
    const verdicts = [];
    if (!us._error && Array.isArray(us.results)) {
      us.results.slice(0,50).forEach(r=>{
        const v = r?.verdicts?.overall;
        if (v && typeof v.malicious === 'boolean') verdicts.push(v.malicious);
      });
    }
    const otx = await fetchJSON(`https://otx.alienvault.com/api/v1/indicators/domain/${encodeURIComponent(domain)}/general`);
    const pulseCount = otx._error ? null : (otx.pulse_info?.count ?? 0);

    let score = 0; const hints = [];
    if (createdISO) {
      const days = Math.floor((Date.now() - Date.parse(createdISO)) / 86400000);
      if (!isNaN(days)) { hints.push(`Domain age: ~${days} days`); if (days < 30) score+=35; else if (days < 90) score+=20; }
    }
    const malHits = verdicts.filter(Boolean).length;
    if (malHits > 0) { score += Math.min(60, 20 + malHits * 8); hints.push(`urlscan malicious matches: ${malHits}`); }
    if (pulseCount !== null) {
      if (pulseCount > 0) { score += Math.min(50, 15 + pulseCount * 5); hints.push(`OTX pulses: ${pulseCount}`); }
      else { hints.push('OTX pulses: 0'); }
    }

    const geoLines = [];
    for (const ip of (ips||[]).slice(0,3)) {
      const info = await ipEnrich(ip);
      geoLines.push(info.text);
    }
    score = Math.max(0, Math.min(100, score));

    const weird = isPunycodeOrWeird(domain);
    if (weird.puny || weird.manyHyphens || weird.longLabel) { score = Math.min(100, score + 10); hints.push('Suspicious domain pattern'); }

    const repText = [
      `Domain: ${domain}`,
      `IPs: ${(ips||[]).join(', ') || '—'}`,
      `Risk Score: ${score} (${score>=70?'High':score>=40?'Medium':'Low'})`,
      '',
      'Signals:',
      `- urlscan malicious sightings: ${malHits}`,
      `- OTX pulses: ${pulseCount === null ? 'Unavailable (CORS/limit)' : pulseCount}`,
      ...(createdISO ? [`- Registered: ${createdISO}`] : []),
      ...(weird.puny ? ['- Punycode: YES'] : []),
      ...(weird.manyHyphens ? ['- Many hyphens: YES'] : []),
      ...(weird.longLabel ? ['- Long label: YES'] : []),
      '',
      'IP / Hosting details:',
      geoLines.join('\n\n') || '—'
    ].join('\n');

    return { score, hints, text: repText };
  }

  // ===== Main runner (same as before, calls the fixed funcs) =====
  async function runLookup() {
    const raw = document.getElementById('domainInput').value.trim();
    if (!raw) return alert('Please enter a domain or URL.');
    const domain = parseInputToDomain(raw);

    document.getElementById('repSummary').innerHTML = 'Checking reputation & hosting…';
    document.getElementById('reputation').textContent = '—';
    document.getElementById('whois').textContent = `Fetching RDAP for ${domain}…`;
    document.getElementById('dns').textContent = `Resolving DNS for ${domain}…`;
    document.getElementById('subs').textContent = `Querying subdomains (urlscan)…`;
    document.getElementById('mail').textContent = `Retrieving SPF/DMARC…`;
    document.getElementById('robots').textContent = `Fetching robots.txt/sitemap.xml…`;
    document.getElementById('wayback').textContent = `Querying Wayback snapshots…`;

    const rd = await lookupRDAP(domain);  document.getElementById('whois').textContent = rd.text;
    const dns = await lookupDNS(domain);  document.getElementById('dns').textContent = dns.text;

    const rep = await reputation(domain, dns.ips || [], rd.created);
    document.getElementById('reputation').textContent = rep.text;
    document.getElementById('repSummary').innerHTML = `
      <div class="row">
        <span class="pill">Domain: ${domain}</span>
        <span class="pill">IPs: ${(dns.ips || []).slice(0,3).join(', ') || '—'}</span>
        <span class="pill">Score: ${riskBadge(rep.score)}</span>
      </div>`;

    const subs = await lookupSubdomains(domain); document.getElementById('subs').textContent = subs || '—';
    const mail = await lookupMail(domain);       document.getElementById('mail').textContent = mail;
    const rob = await robotsAndSitemap(domain);  document.getElementById('robots').textContent = rob;
    const wb  = await wayback(domain);           document.getElementById('wayback').textContent = wb;
  }

  document.getElementById('domainInput').addEventListener('keydown', e => { if (e.key === 'Enter') runLookup(); });
</script>
