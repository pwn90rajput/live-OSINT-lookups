<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>OSINT Lookup Dashboard</title>
  <style>
    :root {
      --bg-color:#0f111a; --panel-bg:#1a1d2b; --accent:#00bfa5; --text:#f5f5f5;
      --muted:#9fa6b2; --border:#2a2e3f; --danger:#ff5252; --warn:#ffd166;
    }
    *{box-sizing:border-box}
    body{font-family:"Segoe UI",Roboto,Arial,sans-serif;background:var(--bg-color);color:var(--text);margin:0}
    header{background:linear-gradient(90deg,#00bfa5,#1de9b6);color:#000;text-align:center;padding:16px 8px;font-weight:600;font-size:1.25rem;letter-spacing:.3px}
    .wrap{max-width:1200px;margin:0 auto;padding:18px}
    .input-bar{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-bottom:14px}
    input[type="text"]{min-width:280px;flex:1;max-width:520px;padding:10px 12px;border-radius:8px;border:1px solid var(--accent);outline:none;background:#151827;color:var(--text)}
    button{background:var(--accent);color:#000;border:none;border-radius:8px;padding:10px 16px;cursor:pointer;font-weight:600}
    button:hover{filter:brightness(1.1)}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:18px}
    .panel{background:var(--panel-bg);border:1px solid var(--border);border-radius:12px;padding:16px;box-shadow:0 4px 8px rgba(0,0,0,.28);transition:.18s}
    .panel:hover{transform:translateY(-3px)}
    .panel h2{margin:0 0 10px;border-bottom:2px solid var(--accent);padding-bottom:8px;font-size:1.05rem}
    .panel pre{background:#11141f;padding:12px;border-radius:8px;overflow:auto;color:var(--muted);font-size:.92rem;line-height:1.4}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;font-size:.8rem;background:#172031;border:1px solid var(--border);color:var(--muted)}
    .score{font-weight:700}
    .score.low{color:#7ad77a}.score.med{color:var(--warn)}.score.high{color:var(--danger)}
    footer{text-align:center;color:var(--muted);padding:18px;margin-top:18px;border-top:1px solid var(--border);font-size:.9rem}
    .hint{color:var(--muted);font-size:.85rem;margin-top:6px}
    .tiny{font-size:.82rem;color:var(--muted)}
  </style>
</head>
<body>
  <header>OSINT Lookup Dashboard</header>
  <div class="wrap">
    <div class="input-bar">
      <input id="domainInput" type="text" placeholder="Enter domain or URL (e.g., https://example.com/some/path)"/>
      <button onclick="runLookup()">Run</button>
    </div>

    <div class="grid">
      <div class="panel">
        <h2>Reputation & Hosting</h2>
        <div id="repSummary" class="tiny">Waiting for input…</div>
        <pre id="reputation">—</pre>
        <div class="hint">Sources: RDAP, Google DNS, ipapi.co, urlscan.io, AlienVault OTX (best-effort)</div>
      </div>

      <div class="panel">
        <h2>WHOIS / RDAP</h2>
        <pre id="whois">Waiting for input…</pre>
      </div>

      <div class="panel">
        <h2>DNS Records</h2>
        <pre id="dns">Waiting for input…</pre>
      </div>

      <div class="panel">
        <h2>Subdomains</h2>
        <pre id="subs">Waiting for input…</pre>
      </div>

      <div class="panel">
        <h2>Mail TXT / SPF / DMARC</h2>
        <pre id="mail">Waiting for input…</pre>
      </div>

      <div class="panel">
        <h2>Robots / Sitemap</h2>
        <pre id="robots">Waiting for input…</pre>
      </div>

      <div class="panel">
        <h2>Wayback Snapshots</h2>
        <pre id="wayback">Waiting for input…</pre>
      </div>
    </div>
  </div>

  <footer>© 2025 OSINT Lookup Pro | Reputation add-on</footer>

  <script>
    // ========== Helper Utilities ==========
    const el = id => document.getElementById(id);

    // Safe fetch with timeout + graceful CORS failure notes
    async function fetchJSON(url, opts = {}, timeoutMs = 12000) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const res = await fetch(url, { ...opts, signal: controller.signal });
        clearTimeout(timer);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
      } catch (e) {
        clearTimeout(timer);
        return { _error: e.message || String(e), _url: url };
      }
    }

    function parseInputToDomain(input) {
      try {
        // If URL, extract hostname; else treat as domain
        if (/^https?:\/\//i.test(input)) return new URL(input).hostname;
        return input.split('/')[0].trim();
      } catch { return input.trim(); }
    }

    function isPunycodeOrWeird(domain) {
      const puny = domain.startsWith('xn--');
      const manyHyphens = (domain.match(/-/g) || []).length >= 3;
      const looksLikeIP = /^\d{1,3}(\.\d{1,3}){3}$/.test(domain);
      const longLabel = domain.split('.').some(l => l.length > 24);
      return { puny, manyHyphens, looksLikeIP, longLabel };
    }

    function riskBadge(score){
      if (score >= 70) return `<span class="score high">${score} (High)</span>`;
      if (score >= 40) return `<span class="score med">${score} (Medium)</span>`;
      return `<span class="score low">${score} (Low)</span>`;
    }

    // ========== Lookups ==========
    async function lookupDNS(domain) {
      // Google DNS over HTTPS
      const aRes = await fetchJSON(`https://dns.google/resolve?name=${encodeURIComponent(domain)}&type=A`);
      const aaaaRes = await fetchJSON(`https://dns.google/resolve?name=${encodeURIComponent(domain)}&type=AAAA`);
      const mxRes = await fetchJSON(`https://dns.google/resolve?name=${encodeURIComponent(domain)}&type=MX`);
      const nsRes = await fetchJSON(`https://dns.google/resolve?name=${encodeURIComponent(domain)}&type=NS`);
      const txtRes = await fetchJSON(`https://dns.google/resolve?name=${encodeURIComponent(domain)}&type=TXT`);

      const lines = [];
      const flattenAnswers = r => (r && r.Answer ? r.Answer.map(a => a.data) : []);
      lines.push(`A: ${flattenAnswers(aRes).join(', ') || '—'}`);
      lines.push(`AAAA: ${flattenAnswers(aaaaRes).join(', ') || '—'}`);
      lines.push(`MX: ${flattenAnswers(mxRes).join(' | ') || '—'}`);
      lines.push(`NS: ${flattenAnswers(nsRes).join(' | ') || '—'}`);
      lines.push(`TXT: ${(flattenAnswers(txtRes).map(t=>t.replace(/^"|"$/g,'')).join(' | ')) || '—'}`);
      return { text: lines.join('\n'), ips: flattenAnswers(aRes) };
    }

    async function lookupRDAP(domain) {
      const rdap = await fetchJSON(`https://rdap.org/domain/${encodeURIComponent(domain)}`);
      if (rdap._error) return { text: `RDAP error: ${rdap._error}`, created: null, registrar: null };
      const created = rdap.events?.find(e => e.eventAction === 'registration')?.eventDate || null;
      const expires = rdap.events?.find(e => e.eventAction === 'expiration')?.eventDate || null;
      const registrar = rdap.entities?.find(e => e.roles?.includes('registrar'))?.vcardArray?.[1]?.find(v=>v[0]==='fn')?.[3] || null;
      const str = [
        `Domain: ${rdap.ldhName || domain}`,
        `Registrar: ${registrar || '—'}`,
        `Registered: ${created || '—'}`,
        `Expires: ${expires || '—'}`
      ].join('\n');
      return { text: str, created, registrar };
    }

    async function ipEnrich(ip) {
      // ipapi.co is public (rate-limited); good for ASN/Geo
      const data = await fetchJSON(`https://ipapi.co/${encodeURIComponent(ip)}/json/`);
      if (data._error) return { ip, text:`${ip} – lookup error: ${data._error}` };
      const bits = [
        `IP: ${ip}`,
        `ASN: ${data.asn || '—'}`,
        `Org/ISP: ${data.org || data.asn_org || '—'}`,
        `Country: ${data.country_name || '—'}`,
        `Region/City: ${data.region || '—'} / ${data.city || '—'}`,
        `Latitude/Longitude: ${data.latitude ?? '—'} / ${data.longitude ?? '—'}`
      ];
      return { ip, text: bits.join('\n'), org: data.org || data.asn_org, country: data.country_name, asn: data.asn };
    }

    async function lookupSubdomains(domain) {
      // urlscan search (public). May return empty if never seen.
      const res = await fetchJSON(`https://urlscan.io/api/v1/search/?q=domain:${encodeURIComponent(domain)}`);
      if (res._error) return `urlscan search error: ${res._error}`;
      const set = new Set();
      (res.results || []).slice(0, 50).forEach(r => {
        const d = r?.page?.domain || r?.task?.domain;
        if (d && (d.endsWith(`.${domain}`) || d === domain)) set.add(d);
      });
      return [...set].slice(0, 25).join('\n') || '—';
    }

    async function lookupMail(domain) {
      const txtRes = await fetchJSON(`https://dns.google/resolve?name=${encodeURIComponent(domain)}&type=TXT`);
      const txts = (txtRes.Answer || []).map(a => a.data.replace(/^"|"$/g,''));
      const spf = txts.find(t => /^v=spf1/i.test(t)) || '—';
      const dmarcRes = await fetchJSON(`https://dns.google/resolve?name=_dmarc.${encodeURIComponent(domain)}&type=TXT`);
      const dmarc = (dmarcRes.Answer || []).map(a=>a.data.replace(/^"|"$/g,'')).find(t=>/^v=DMARC1/i.test(t)) || '—';
      return `SPF: ${spf}\nDMARC: ${dmarc}`;
    }

    async function robotsAndSitemap(domain) {
      async function getText(url) {
        try {
          const r = await fetch(url, { mode:'cors' });
          if (!r.ok) throw new Error(`HTTP ${r.status}`);
          return await r.text();
        } catch (e) { return `Not Found or blocked (${e.message})`; }
      }
      const robots = await getText(`https://${domain}/robots.txt`);
      const sitemap = await getText(`https://${domain}/sitemap.xml`);
      return `robots.txt:\n${(robots||'').slice(0,800) || '—'}\n\nsitemap.xml:\n${(sitemap||'').slice(0,800) || '—'}`;
    }

    async function wayback(domain) {
      const r = await fetchJSON(`https://web.archive.org/cdx/search/cdx?url=${encodeURIComponent(domain)}/*&output=json&fl=timestamp,original&limit=5&filter=statuscode:200&collapse=timestamp:8`);
      if (r._error) return `Wayback error: ${r._error}`;
      if (!Array.isArray(r) || r.length < 2) return 'No snapshots found.';
      const rows = r.slice(1).map(row => {
        const ts = row[0];
        const y = ts.slice(0,4), m = ts.slice(4,6), d = ts.slice(6,8);
        return `${y}-${m}-${d}  ${row[1]}`;
      });
      return `Recent snapshots:\n${rows.join('\n')}`;
    }

    async function reputation(domain, ips, createdISO) {
      // urlscan verdicts
      const us = await fetchJSON(`https://urlscan.io/api/v1/search/?q=domain:${encodeURIComponent(domain)}`);
      const verdicts = [];
      if (!us._error && Array.isArray(us.results)) {
        us.results.slice(0,50).forEach(r=>{
          const v = r?.verdicts?.overall;
          if (v && typeof v.malicious === 'boolean') verdicts.push(v.malicious);
        });
      }

      // AlienVault OTX domain pulses
      const otx = await fetchJSON(`https://otx.alienvault.com/api/v1/indicators/domain/${encodeURIComponent(domain)}/general`);
      const pulseCount = otx._error ? null : (otx.pulse_info?.count ?? 0);

      // Simple heuristics
      let score = 0;
      const hints = [];

      // 1) Newly registered domains are risky
      if (createdISO) {
        const days = Math.floor((Date.now() - Date.parse(createdISO)) / 86400000);
        if (!isNaN(days)) {
          hints.push(`Domain age: ~${days} days`);
          if (days < 30) score += 35;
          else if (days < 90) score += 20;
        }
      }

      // 2) urlscan malicious sightings
      const malHits = verdicts.filter(Boolean).length;
      if (malHits > 0) { score += Math.min(60, 20 + malHits * 8); hints.push(`urlscan malicious matches: ${malHits}`); }

      // 3) OTX pulses
      if (pulseCount !== null) {
        if (pulseCount > 0) { score += Math.min(50, 15 + pulseCount * 5); hints.push(`OTX pulses: ${pulseCount}`); }
        else { hints.push('OTX pulses: 0'); }
      }

      // 4) IP geos & hosting (no penalty by default, but note if residential ASN patterns)
      const geoLines = [];
      for (const ip of ips.slice(0,3)) {
        const ipInfo = await ipEnrich(ip);
        geoLines.push(ipInfo.text);
        if ((ipInfo.org||'').toLowerCase().includes('pppoe') || (ipInfo.org||'').toLowerCase().includes('residential')) {
          score += 10;
          hints.push(`Residential-looking ASN for ${ip}`);
        }
      }

      // Clamp to 0–100
      score = Math.max(0, Math.min(100, score));

      // Legitimacy quick check
      const weird = isPunycodeOrWeird(domain);
      if (weird.puny || weird.manyHyphens || weird.longLabel) {
        score = Math.min(100, score + 10);
        hints.push('Suspicious domain pattern');
      }

      const repText = [
        `Domain: ${domain}`,
        `IPs: ${ips.join(', ') || '—'}`,
        `Risk Score: ${score} (${score>=70?'High':score>=40?'Medium':'Low'})`,
        '',
        'Signals:',
        `- urlscan malicious sightings: ${malHits}`,
        `- OTX pulses: ${pulseCount === null ? 'Unavailable (CORS/limit)' : pulseCount}`,
        ...(createdISO ? [`- Registered: ${createdISO}`] : []),
        ...(weird.puny ? ['- Punycode: YES'] : []),
        ...(weird.manyHyphens ? ['- Many hyphens: YES'] : []),
        ...(weird.longLabel ? ['- Long label: YES'] : []),
        '',
        'IP / Hosting details:',
        geoLines.join('\n\n') || '—'
      ].join('\n');

      return { score, hints, text: repText };
    }

    // ========== Main ==========
    async function runLookup() {
      const raw = el('domainInput').value.trim();
      if (!raw) return alert('Please enter a domain or URL.');
      const domain = parseInputToDomain(raw);

      // Reset UI
      el('repSummary').innerHTML = 'Checking reputation & hosting…';
      el('reputation').textContent = '—';
      el('whois').textContent = `Fetching RDAP for ${domain}…`;
      el('dns').textContent = `Resolving DNS for ${domain}…`;
      el('subs').textContent = `Querying subdomains (urlscan)…`;
      el('mail').textContent = `Retrieving SPF/DMARC…`;
      el('robots').textContent = `Fetching robots.txt/sitemap.xml…`;
      el('wayback').textContent = `Querying Wayback snapshots…`;

      // Run in sequence where dependencies exist
      const rd = await lookupRDAP(domain);
      el('whois').textContent = rd.text;

      const dns = await lookupDNS(domain);
      el('dns').textContent = dns.text;

      const rep = await reputation(domain, dns.ips || [], rd.created);
      el('reputation').textContent = rep.text;
      el('repSummary').innerHTML = `
        <div class="row">
          <span class="pill">Domain: ${domain}</span>
          <span class="pill">IPs: ${(dns.ips || []).slice(0,3).join(', ') || '—'}</span>
          <span class="pill">Score: ${riskBadge(rep.score)}</span>
        </div>
      `;

      const subs = await lookupSubdomains(domain);
      el('subs').textContent = subs || '—';

      const mail = await lookupMail(domain);
      el('mail').textContent = mail;

      const rob = await robotsAndSitemap(domain);
      el('robots').textContent = rob;

      const wb = await wayback(domain);
      el('wayback').textContent = wb;
    }

    // Optional: allow Enter to trigger
    document.getElementById('domainInput').addEventListener('keydown', e => {
      if (e.key === 'Enter') runLookup();
    });

    // ======= Optional: API Key Slots (future enrichment) =======
    // const VT_API_KEY = ''; // add VirusTotal API key to enrich score
    // const IPQS_KEY = '';   // add IPQualityScore key for URL/IP risk
  </script>
</body>
</html>
